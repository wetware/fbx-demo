// Code generated by capnpc-go. DO NOT EDIT.

package tiktok

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type User capnp.Struct

// User_TypeID is the unique identifier for the type User.
const User_TypeID = 0xeb52f0469fccdeb7

func NewUser(s *capnp.Segment) (User, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return User(st), err
}

func NewRootUser(s *capnp.Segment) (User, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return User(st), err
}

func ReadRootUser(msg *capnp.Message) (User, error) {
	root, err := msg.Root()
	return User(root.Struct()), err
}

func (s User) String() string {
	str, _ := text.Marshal(0xeb52f0469fccdeb7, capnp.Struct(s))
	return str
}

func (s User) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (User) DecodeFromPtr(p capnp.Ptr) User {
	return User(capnp.Struct{}.DecodeFromPtr(p))
}

func (s User) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s User) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s User) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s User) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s User) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s User) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s User) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s User) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s User) Uid() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s User) HasUid() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s User) UidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s User) SetUid(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s User) Nickname() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s User) HasNickname() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s User) NicknameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s User) SetNickname(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

// User_List is a list of User.
type User_List = capnp.StructList[User]

// NewUser creates a new list of User.
func NewUser_List(s *capnp.Segment, sz int32) (User_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[User](l), err
}

// User_Future is a wrapper for a User promised by a client call.
type User_Future struct{ *capnp.Future }

func (f User_Future) Struct() (User, error) {
	p, err := f.Future.Ptr()
	return User(p.Struct()), err
}

type Comment capnp.Struct

// Comment_TypeID is the unique identifier for the type Comment.
const Comment_TypeID = 0xb14c9b4fd22547c2

func NewComment(s *capnp.Segment) (Comment, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Comment(st), err
}

func NewRootComment(s *capnp.Segment) (Comment, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Comment(st), err
}

func ReadRootComment(msg *capnp.Message) (Comment, error) {
	root, err := msg.Root()
	return Comment(root.Struct()), err
}

func (s Comment) String() string {
	str, _ := text.Marshal(0xb14c9b4fd22547c2, capnp.Struct(s))
	return str
}

func (s Comment) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Comment) DecodeFromPtr(p capnp.Ptr) Comment {
	return Comment(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Comment) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Comment) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Comment) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Comment) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Comment) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Comment) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Comment) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Comment) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Comment) MediaId() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Comment) HasMediaId() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Comment) MediaIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Comment) SetMediaId(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Comment) Author() (User, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return User(p.Struct()), err
}

func (s Comment) HasAuthor() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Comment) SetAuthor(v User) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewAuthor sets the author field to a newly
// allocated User struct, preferring placement in s's segment.
func (s Comment) NewAuthor() (User, error) {
	ss, err := NewUser(capnp.Struct(s).Segment())
	if err != nil {
		return User{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Comment) Text() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Comment) HasText() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Comment) TextBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Comment) SetText(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Comment) Replies() (Comment_List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return Comment_List(p.List()), err
}

func (s Comment) HasReplies() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Comment) SetReplies(v Comment_List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewReplies sets the replies field to a newly
// allocated Comment_List, preferring placement in s's segment.
func (s Comment) NewReplies(n int32) (Comment_List, error) {
	l, err := NewComment_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Comment_List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Comment_List is a list of Comment.
type Comment_List = capnp.StructList[Comment]

// NewComment creates a new list of Comment.
func NewComment_List(s *capnp.Segment, sz int32) (Comment_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return capnp.StructList[Comment](l), err
}

// Comment_Future is a wrapper for a Comment promised by a client call.
type Comment_Future struct{ *capnp.Future }

func (f Comment_Future) Struct() (Comment, error) {
	p, err := f.Future.Ptr()
	return Comment(p.Struct()), err
}
func (p Comment_Future) Author() User_Future {
	return User_Future{Future: p.Future.Field(2, nil)}
}

type TikTok capnp.Client

// TikTok_TypeID is the unique identifier for the type TikTok.
const TikTok_TypeID = 0xb61751eadcf2ee19

func (c TikTok) Mention(ctx context.Context, params func(TikTok_mention_Params) error) (TikTok_mention_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xb61751eadcf2ee19,
			MethodID:      0,
			InterfaceName: "tiktok.capnp:TikTok",
			MethodName:    "mention",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(TikTok_mention_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return TikTok_mention_Results_Future{Future: ans.Future()}, release

}

func (c TikTok) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c TikTok) String() string {
	return "TikTok(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c TikTok) AddRef() TikTok {
	return TikTok(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c TikTok) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c TikTok) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c TikTok) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (TikTok) DecodeFromPtr(p capnp.Ptr) TikTok {
	return TikTok(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c TikTok) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c TikTok) IsSame(other TikTok) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c TikTok) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c TikTok) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A TikTok_Server is a TikTok with a local implementation.
type TikTok_Server interface {
	Mention(context.Context, TikTok_mention) error
}

// TikTok_NewServer creates a new Server from an implementation of TikTok_Server.
func TikTok_NewServer(s TikTok_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(TikTok_Methods(nil, s), s, c)
}

// TikTok_ServerToClient creates a new Client from an implementation of TikTok_Server.
// The caller is responsible for calling Release on the returned Client.
func TikTok_ServerToClient(s TikTok_Server) TikTok {
	return TikTok(capnp.NewClient(TikTok_NewServer(s)))
}

// TikTok_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func TikTok_Methods(methods []server.Method, s TikTok_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xb61751eadcf2ee19,
			MethodID:      0,
			InterfaceName: "tiktok.capnp:TikTok",
			MethodName:    "mention",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Mention(ctx, TikTok_mention{call})
		},
	})

	return methods
}

// TikTok_mention holds the state for a server call to TikTok.mention.
// See server.Call for documentation.
type TikTok_mention struct {
	*server.Call
}

// Args returns the call's arguments.
func (c TikTok_mention) Args() TikTok_mention_Params {
	return TikTok_mention_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c TikTok_mention) AllocResults() (TikTok_mention_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TikTok_mention_Results(r), err
}

// TikTok_List is a list of TikTok.
type TikTok_List = capnp.CapList[TikTok]

// NewTikTok_List creates a new list of TikTok.
func NewTikTok_List(s *capnp.Segment, sz int32) (TikTok_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[TikTok](l), err
}

type TikTok_mention_Params capnp.Struct

// TikTok_mention_Params_TypeID is the unique identifier for the type TikTok_mention_Params.
const TikTok_mention_Params_TypeID = 0xbb0bedda65765ef0

func NewTikTok_mention_Params(s *capnp.Segment) (TikTok_mention_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TikTok_mention_Params(st), err
}

func NewRootTikTok_mention_Params(s *capnp.Segment) (TikTok_mention_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return TikTok_mention_Params(st), err
}

func ReadRootTikTok_mention_Params(msg *capnp.Message) (TikTok_mention_Params, error) {
	root, err := msg.Root()
	return TikTok_mention_Params(root.Struct()), err
}

func (s TikTok_mention_Params) String() string {
	str, _ := text.Marshal(0xbb0bedda65765ef0, capnp.Struct(s))
	return str
}

func (s TikTok_mention_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TikTok_mention_Params) DecodeFromPtr(p capnp.Ptr) TikTok_mention_Params {
	return TikTok_mention_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TikTok_mention_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TikTok_mention_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TikTok_mention_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TikTok_mention_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// TikTok_mention_Params_List is a list of TikTok_mention_Params.
type TikTok_mention_Params_List = capnp.StructList[TikTok_mention_Params]

// NewTikTok_mention_Params creates a new list of TikTok_mention_Params.
func NewTikTok_mention_Params_List(s *capnp.Segment, sz int32) (TikTok_mention_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[TikTok_mention_Params](l), err
}

// TikTok_mention_Params_Future is a wrapper for a TikTok_mention_Params promised by a client call.
type TikTok_mention_Params_Future struct{ *capnp.Future }

func (f TikTok_mention_Params_Future) Struct() (TikTok_mention_Params, error) {
	p, err := f.Future.Ptr()
	return TikTok_mention_Params(p.Struct()), err
}

type TikTok_mention_Results capnp.Struct

// TikTok_mention_Results_TypeID is the unique identifier for the type TikTok_mention_Results.
const TikTok_mention_Results_TypeID = 0xa65a4e044f9f760f

func NewTikTok_mention_Results(s *capnp.Segment) (TikTok_mention_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TikTok_mention_Results(st), err
}

func NewRootTikTok_mention_Results(s *capnp.Segment) (TikTok_mention_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return TikTok_mention_Results(st), err
}

func ReadRootTikTok_mention_Results(msg *capnp.Message) (TikTok_mention_Results, error) {
	root, err := msg.Root()
	return TikTok_mention_Results(root.Struct()), err
}

func (s TikTok_mention_Results) String() string {
	str, _ := text.Marshal(0xa65a4e044f9f760f, capnp.Struct(s))
	return str
}

func (s TikTok_mention_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TikTok_mention_Results) DecodeFromPtr(p capnp.Ptr) TikTok_mention_Results {
	return TikTok_mention_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TikTok_mention_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TikTok_mention_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TikTok_mention_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TikTok_mention_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TikTok_mention_Results) Comment() (Comment, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Comment(p.Struct()), err
}

func (s TikTok_mention_Results) HasComment() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TikTok_mention_Results) SetComment(v Comment) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewComment sets the comment field to a newly
// allocated Comment struct, preferring placement in s's segment.
func (s TikTok_mention_Results) NewComment() (Comment, error) {
	ss, err := NewComment(capnp.Struct(s).Segment())
	if err != nil {
		return Comment{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// TikTok_mention_Results_List is a list of TikTok_mention_Results.
type TikTok_mention_Results_List = capnp.StructList[TikTok_mention_Results]

// NewTikTok_mention_Results creates a new list of TikTok_mention_Results.
func NewTikTok_mention_Results_List(s *capnp.Segment, sz int32) (TikTok_mention_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[TikTok_mention_Results](l), err
}

// TikTok_mention_Results_Future is a wrapper for a TikTok_mention_Results promised by a client call.
type TikTok_mention_Results_Future struct{ *capnp.Future }

func (f TikTok_mention_Results_Future) Struct() (TikTok_mention_Results, error) {
	p, err := f.Future.Ptr()
	return TikTok_mention_Results(p.Struct()), err
}
func (p TikTok_mention_Results_Future) Comment() Comment_Future {
	return Comment_Future{Future: p.Future.Field(0, nil)}
}

const schema_fe4bf44cd2322767 = "x\xda|\x92\xcfk\x13A\x1c\xc5\xdf\x9b\xd9u\x05\x9b" +
	"\xb6\xc3.\x88\xb9\x14JE\x10,\xfe\xb8\xf5\xd2P\x7f" +
	"\x94j\xb4\x99\x12A<\x08K\xba\xe8\xb2\xddlH6" +
	"\xa5\x07K\x14*TP\x10\xaf\"EQ\x0f^\xc4\x8b" +
	"\x1e\xc4C\x85\x1e\x04O\x05/\"\xfe\x01J\xa5\x88g" +
	"W&\xb5I\x8c\xe0mv\xf8\xbe\xf7\xf6}\xbes4" +
	"\xcf\x82u,7\"!\xf4\x98\xbd'\x1bZ\\\x9b\xb5" +
	".\\~\x06\xe5\x11\xb0\xe9\x00'\x9a\x1c%\xe8.s" +
	"\x12\xcc\xdeM\x1f\xdc\x9c}P|\x09\x95cv\xf5\xd0" +
	"\xf1\xcd\xe2\xcfs\xbf`\xdb\x0e\xe0>\xe4s\xf7i[" +
	"\xf2\x88#\x04\xb3\x03\xdf\x7f|\xfe\xaa\xf7\xbf\x82\xca\xc9" +
	"\xee0\xe8\xae\x8b\xc7\xee{a4\x1bb\xda\xdd2\xa7" +
	"l\xfb\xcab\xf0ik\xdf\x9b\x9dh\xcb\xd8|\x14y" +
	"\xc2\xca^\x7f\xf9\xb0vf{\xee[_\xa64\xfa\xb7" +
	"\xe2\xbe\xbb\xd1vZ\x17/p$K\xc3(M\xa2\xf1" +
	"\x8a\xf4k\xd5\xdaD9\x8c\xcaI4\x1e\x07\xd54L" +
	"\xaacsA\xa3\xe9,\xa4\x0dmI\x0b\xb0\x08\xa8\xdc" +
	"\x14\xa0\xf7JjO\xb0UIb3\xca\xe1nM\x90" +
	"\xc3`\xc7\x96m\xdb\x93I<d\x06K\xa4\xf6:V" +
	"\xcby@/I\xea\x15AEz4\x977\x8d\xffu" +
	"I\xbd*\xa8\x84\xf0(\x00uk\x02\xd07$\xf5\x1d" +
	"A%\xa5G\x09\xa8\xdb\x87\x01\xbd\"\xa9\xef\x09*\xcb" +
	"\xf2h\x01\xea\xae\x91\xafJ\xea'\x822\x9c\xe7\x00\x04" +
	"\x07\xc0V\x1c\xcc\x87\xfeL\xe7{\xd2o\xa6\xd7\x92:" +
	"\x87\xbb\xacv~|(\x0d\x96\xd2\x8e\xaa\x1e\xd4\x16\xc2" +
	"\xa0\xc1A\xb0$\xd9Ws\xf0\x9f\x9a\xe50r\xcaI" +
	"dZZ\xd2\xeeY\x11w\x9f\x89RS\x10\xcavZ" +
	"\x7f\x08\x17X\"\xff\xbf\x83\x92_\xf7e\xdc\xe8\x8b\xba" +
	"\xd8\x08X7A\x03\x1d\x9c\xa7\x0d\xce\x82\xa4.\xf6\xe0" +
	"\x9c\x19\x05\xf4)I]\xea\xc1y\xfe,\xa0\x8b\x92\xfa" +
	"\xd2_\x90\x9cf\xf7\x9cU\xc3JT\xf5\xe3\x00\xc0\xee" +
	"\xdd\xef\x00\x00\x00\xff\xffj\xba\xbb\xc1"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_fe4bf44cd2322767,
		Nodes: []uint64{
			0xa65a4e044f9f760f,
			0xb14c9b4fd22547c2,
			0xb61751eadcf2ee19,
			0xbb0bedda65765ef0,
			0xeb52f0469fccdeb7,
		},
		Compressed: true,
	})
}
